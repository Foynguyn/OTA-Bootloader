/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body - STM32 Bootloader for ESP32 communication
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "stm32f103xx.h"
#include <string.h>

/* define Address Sources
STM32F103C8T6 has 128KB flash:
Bootloader: 0x08000000 - 0x08003FFF (16KB)
Application: 0x08004000 - 0x0801FFFF (112KB)
*/


#define APP_CURRENT								0x08004000U
#define APP_END									0x0801FFFFU
#define APP_CURRENT_FLAG						0x08011C00U
#define APP_SIZE								111
#define APP_MAX_SIZE							(APP_SIZE * 1024)  /* 111KB in bytes*/

/* Protocol Commands for ESP32-STM32 Communication (matching ESP32)*/
#define FW_REQUEST								28
#define FW_LENGTH								2
#define CHECKSUM_DATA 							6

/* Protocol Responses from STM32 (matching ESP32)*/
#define FW_READY 								31
#define FW_ERR 									4
#define FW_OK 									3
#define FW_RECEIVED 							5
#define CHECKSUM_OK 							7
#define CHECKSUM_ERR 							8

#define DATA_CHUNK_SIZE							8     /* 8 bytes per chunk (matching ESP32)*/
#define UART_BUFFER_SIZE						8    /* Buffer for UART data*/

/* declare handler*/
USART_Handle_t uart1;
GPIO_Handle_t gpio;

/* Bootloader states*/
typedef enum {
	CHECK_FLAG,
	WAIT_REQUEST,    		/* Wait for FW_REQUEST from ESP32*/
	SEND_READY,          	/* Send FW_READY to ESP32*/
	WAIT_LENGTH,     		/* Wait for FW_LENGTH from ESP32*/
	RECEIVE_DATA,        	/* Receive firmware data from ESP32*/
	VERIFY_CHECKSUM,     	/* Verify firmware checksum*/
	JUMP_TO_APP          	/* Jump to application*/
} bootloader_state_t;

/* Global variables*/
bootloader_state_t bl_state = CHECK_FLAG;
uint8_t uart_rx_buffer[UART_BUFFER_SIZE];
uint8_t uart_tx_buffer[UART_BUFFER_SIZE];
uint8_t data_received = 0;
uint32_t firmware_size = 0;
uint32_t bytes_received = 0;
uint32_t flash_write_address = APP_CURRENT;
uint32_t calculated_checksum = 0;
uint32_t esp32_checksum = 0;
uint32_t timeout_counter = 0;

/* Function prototype */
void GPIO_Configure(void);
void UART_Configure(void);
void SendResponseByte(uint8_t response);
uint8_t WaitForData(uint32_t timeout);

int main(void)
{
	/* Initialize peripherals */
	GPIO_Configure();
	UART_Configure();
	NVIC_InterruptConfig(IRQ_NO_USART1, ENABLE);
	USART_Start(uart1.pUSARTx);

	/* Clear UART buffer */
	memset(uart_rx_buffer, 0, sizeof(uart_rx_buffer));
	memset(uart_tx_buffer, 0, sizeof(uart_tx_buffer));

	/* Check if valid application exists - if yes, wait limited time for update request */
	uint8_t valid_app_exists = 0;

	/* Basic application validation */
	if(Bootloader_CheckApp(APP_CURRENT, APP_END))
	{
		valid_app_exists = 1;
	}

	/* Main bootloader state machine */
	while(1) {
		switch(bl_state) {
			case CHECK_FLAG:
			{
				uint8_t flag[4];
				FLASH_ReadData(APP_CURRENT_FLAG, (uint32_t*)flag, 1);

				if(flag[0] == 0x0001){/* co yeu cau update khi dang chay app */
					FLASH_RemovePartition(APP_CURRENT, 111);
					/* Having update annoucement, sending ready cmd */
					bl_state = SEND_READY;
				}
				else{
					if (valid_app_exists)
					{
						bl_state = JUMP_TO_APP;
					}
					else
					{
						bl_state = WAIT_REQUEST;
					}
				}
				break;
			}
			case WAIT_REQUEST: {
				/* Wait for "FW_REQUEST" */
				WaitForData(500);
				data_received = 0;
				memset(uart_rx_buffer, 0, sizeof(uart_rx_buffer));
				bl_state = SEND_READY;
				break;
			}

			case SEND_READY:
			{
				/* Send FW_READY response to ESP32 */
				SendResponseByte(FW_READY);
				memset(uart_rx_buffer, 0, sizeof(uart_rx_buffer));
				memset(uart_tx_buffer, 0, sizeof(uart_tx_buffer));
				bl_state = WAIT_LENGTH;
				break;
			}

			case WAIT_LENGTH:
			{
				/* Wait for FW_LENGTH command (1 command byte + 4 data bytes) */
				if(WaitForData(500)) { // 500 ms timeout
					if(uart_rx_buffer[0] == FW_LENGTH) {
						/* Extract 32-bit length in big-endian format (matching ESP32) */
						firmware_size = (uart_rx_buffer[1] << 24) |
						               (uart_rx_buffer[2] << 16) |
						               (uart_rx_buffer[3] << 8) |
						               uart_rx_buffer[4];

						/* Validate firmware size */
						if(firmware_size > 0 && firmware_size <= APP_MAX_SIZE) {
							SendResponseByte(FW_OK);
							memset(uart_rx_buffer, 0, sizeof(uart_rx_buffer));
							memset(uart_tx_buffer, 0, sizeof(uart_tx_buffer));
							/* Reset variables for data reception */
							bytes_received = 0;
							flash_write_address = APP_CURRENT;
							calculated_checksum = 0;
							bl_state = RECEIVE_DATA;
						} else {
							SendResponseByte(FW_ERR);
							bl_state = WAIT_REQUEST; /* Go back to wait for new request */
						}
					}
				} else {
					/* Timeout - if valid app exists, jump to it; otherwise wait again */
					memset(uart_rx_buffer, 0, sizeof(uart_rx_buffer));
					memset(uart_tx_buffer, 0, sizeof(uart_tx_buffer));
					bl_state = WAIT_REQUEST;
				}
				break;
			}

			case RECEIVE_DATA:
			{
				/* Wait for data chunks or checksum command
				Use shorter timeout if all firmware data received */
				uint32_t wait_timeout = (bytes_received >= firmware_size) ? 1000 : 10000;
				/* Receive remaining bytes in the last chunk */
				uint32_t remaining = firmware_size - bytes_received;
				uint8_t chunk_size = (remaining >= DATA_CHUNK_SIZE) ? DATA_CHUNK_SIZE : remaining;

				if (bytes_received >= firmware_size) {
					/* firmware was sent all, wait for checksum */
					data_received = 0;
					USART_ReceiveDataIT(&uart1, uart_rx_buffer, 5);
					uint32_t timeout_counter = 0;
					uint32_t timeout_limit = wait_timeout * 1000;
					while(timeout_counter < timeout_limit && !data_received) {
						timeout_counter++;
					}
					if(data_received && uart_rx_buffer[0] == CHECKSUM_DATA) {
						esp32_checksum = (uart_rx_buffer[1] << 24) |
										 (uart_rx_buffer[2] << 16) |
										 (uart_rx_buffer[3] << 8) |
										 uart_rx_buffer[4];
						bl_state = VERIFY_CHECKSUM;
						break;
					}
				} else {
					/* receive the last chunk from UART */
					data_received = 0;
					USART_ReceiveDataIT(&uart1, uart_rx_buffer, chunk_size);
					uint32_t timeout_counter = 0;
					uint32_t timeout_limit = wait_timeout * 1000;
					while(timeout_counter < timeout_limit && !data_received) {
						timeout_counter++;
					}
					if(data_received) {
						/* checksum algorithm */
						for(uint8_t i = 0; i < chunk_size; i++) {
							calculated_checksum += uart_rx_buffer[i];
						}


						if (chunk_size == DATA_CHUNK_SIZE) {
							/* Chunk has 8 bytes */
							FLASH_WriteData(flash_write_address, (uint32_t*)uart_rx_buffer, 2);
						} else {
							/* the last chunk < 8 bytes - pad with 0xFF and write 2 words */
							uint8_t padded_data[DATA_CHUNK_SIZE];
							memset(padded_data, 0xFF, DATA_CHUNK_SIZE);
							memcpy(padded_data, uart_rx_buffer, chunk_size);
							FLASH_WriteData(flash_write_address, (uint32_t*)padded_data, 2);
						}

						flash_write_address += chunk_size;
						bytes_received += chunk_size;
						SendResponseByte(FW_RECEIVED);
					}
				}
				break;
			}

			case VERIFY_CHECKSUM:
			{
				/* Compare checksums */
				uint32_t stm32_checksum = calculated_checksum % 256;

				if(stm32_checksum == esp32_checksum) {
					SendResponseByte(CHECKSUM_OK);
					bl_state = JUMP_TO_APP;
				} else {
					SendResponseByte(CHECKSUM_ERR);
					bl_state = WAIT_REQUEST;
				}
				break;
			}

			case JUMP_TO_APP:
			{
				NVIC_InterruptConfig(IRQ_NO_USART1, DISABLE);

				Bootloader_JumpApp(APP_CURRENT);
				break;
			}
		}
	}
}

void GPIO_Configure(void)
{
	gpio.pGPIOx = GPIOA;
	gpio.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;

	/* TX Pin (PA9) - USART1 */
	gpio.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_9;
	gpio.GPIO_PinConfig.GPIO_PinAltFunMode = GPIO_ALT_MODE_USART_TX_FULLDUP;
	GPIO_Init(&gpio);

	/* RX Pin (PA10) - USART1 */
	gpio.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_10;
	gpio.GPIO_PinConfig.GPIO_PinAltFunMode = GPIO_ALT_MODE_USART_RX_FULLDUP;
	GPIO_Init(&gpio);
}

void UART_Configure(void)
{
	uart1.pUSARTx = USART1;
	uart1.USART_Config.USART_Baudrate = USART_STD_BAUD_115200;
	uart1.USART_Config.USART_HWFLowControl = USART_HW_FLOW_CTRL_NONE;
	uart1.USART_Config.USART_Mode = USART_MODE_TXRX;
	uart1.USART_Config.USART_NumberOfStopBits = USART_STOPBITS_1;
	uart1.USART_Config.USART_ParityControl = USART_PARITY_DISABLE;
	uart1.USART_Config.USART_WordLength = USART_WORDLEN_8BITS;
	USART_Init(&uart1);
}

void SendResponseByte(uint8_t response)
{
	uart_tx_buffer[0] = response;
	USART_SendData(&uart1, uart_tx_buffer, 1);
}

uint8_t WaitForData(uint32_t timeout_ms)
{
	/* Clear buffer before receiving */
	memset(uart_rx_buffer, 0, sizeof(uart_rx_buffer));
	data_received = 0;

	/* Start receiving first byte */
	USART_ReceiveDataIT(&uart1, uart_rx_buffer, 1);

	uint32_t timeout_counter = 0;
	uint32_t timeout_limit = timeout_ms * 1000; /* Convert to microseconds roughly */

	while(timeout_counter < timeout_limit) {
		if(data_received) {
			/* Check if we need to receive more bytes */
			if(uart_rx_buffer[0] == FW_LENGTH || uart_rx_buffer[0] == CHECKSUM_DATA) {
				/* Need to receive 4 more bytes for the 32-bit data */
				data_received = 0;
				USART_ReceiveDataIT(&uart1, &uart_rx_buffer[1], 4);

				/* Wait for the remaining 4 bytes */
				timeout_counter = 0; /* Reset timeout for additional bytes */
				while(timeout_counter < timeout_limit && !data_received) {
					timeout_counter++;
				}
				return data_received ? 1 : 0;
			}
			else if(uart_rx_buffer[0] == CHECKSUM_DATA){

			}
			else if(uart_rx_buffer[0] != FW_REQUEST && uart_rx_buffer[0] != CHECKSUM_DATA && uart_rx_buffer[0] != FW_LENGTH) {
				/* This might be data chunk - receive remaining 7 bytes */
				data_received = 0;
				USART_ReceiveDataIT(&uart1, &uart_rx_buffer[1], DATA_CHUNK_SIZE - 1);

				/* Wait for remaining bytes */
				timeout_counter = 0;
				while(timeout_counter < timeout_limit && !data_received) {
					timeout_counter++;
				}
				return data_received ? 1 : 0;
			} else {
				/* Single byte command received */
				return 1;
			}
		}
		timeout_counter++;
	}

	return 0; /* Timeout */
}

/* USART interrupt callback */
void USART_ReceptionEventsCallback(USART_Handle_t *pUSARTHandle)
{
	data_received = 1;
}
